\documentclass{scrartcl}

\usepackage[latin9]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{parskip}

\usepackage{color}
\definecolor{gray}{gray}{0.50}
\usepackage{listings}
\lstset{language=Octave, basicstyle=\small, tabsize=8,frame = single,commentstyle = \color{gray},
  breaklines=true, caption=\texttt\lstname, captionpos=b}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
{<5><6><7><8><9><10><10.95><12><14.4><17.28><20.74><24.88>cmttb10}{}

\pagestyle{headings}

\begin{document}

\begin{titlepage}
\title{4. Projekt für Numerische Mathematik UE \\
Numerische Integration über mehrdimensionale Gebiete}
\author{Thomas Baumhauer, Judith Braunsteiner,\\
Gabriel Ebner, Johannes Hafner,\\
Clemens Müllner, Christina Satzinger}
\maketitle
\end{titlepage}

\section{Fehlerabschätzungen bei mehrdimensionaler Integration}

Um eine Fehlerabsch"atzung f"ur die Mehrdimensionalen Quatratur zu erhalten geht man
eben so wie das Verfahren mit Hilfe von Fubini vor.\\

Geht man nun von einer $d$ dimensionalen Funktion aus, mit eindimensionalen Quatraturen mit Anzahl der St"utzstellen $n_d$ so
kann man folgendes beobachten:\

%\begin{eqnarray*}
$\int_{\times [a_k,b_k]} f(x_1,...,x_d) d(x_1,...,x_d)=\int_{a_1}^{b^1} ... \int_{a_d}^{b^d} f(x_1,...,x_d) dx_d...dx_1$\\
$=\int_{a_1}^{b^1} ... \int_{a_{d-1}}^{b^{d-1}} \sum_{i=1}^{n_d} f(x_1,...,x_{d-1},x^i_d)g_d^i + o(d)  dx_1...dx_{d-1}$\\
Wobei $o(k)$ den Fehlerterm  $\int_{a_k}^{b^k} f(x_1,...,x_d) dx_k - \sum_{i=1}^{n_k} f(x_1,...,,x^i_k,...x_k)g_k^i$ bezeichnet,
also den der eindimensionalen Quatratur.\\
$=\int_{a_1}^{b^1} ... \int_{a_{d-1}}^{b^{d-1}} \sum_{j=1}^{n_{d-1}} (\sum_{i=1}^{n_d} f(x_1,..., x_{d-2},x^j_{d-1},x^i_d)g_d^i +
o(k))g_{d-1}^i + o(d-1)  dx_1...dx_{d-2}$\\
$=...=\sum_{i_1=1}^{n_1}...\sum_{i_d=1}^{n_d}f(x_1^{i_1},...,x^{i_d}_d)\prod_{k=1}^d g_k^{i_k} + \sum_{k=1}^d o(k)$\\
Die Gewichte einer Quatratur summieren sich auf eins, wodurch sie bei den Fehlertermen wegfallen
(Vorrausgesetzt nat"urlich $g_k^i\le 1 \forall i, k$).
Die erste Summe, ist genau das was, das Mehrdimensionalequatraturverfahren berrechnet. Die zweite Summe Verbleibt als neuer Fehler.\\
%\end{eqnarray*}

Man sieht also, dass sich die Fehler im schlimmsten Fall aufsummieren. W"ahlt man f"ur alle Dimensionen das selbe Verfahren selber Ordnung,
so ergibt sich also ein Fehler der Ordnung $d*o$ wobei $o$ den Fehler der Eindimensionalen Quatratur bezeichnet, der im Allgemeinen von
der Intervalll"ange, der Anzahl der St"utzstellen n und h"oheren Ableitungen der Funktion abh"angt. 

\section{Programmaufbau}

Nach dem Satz von Fubini gilt für Integrationsgebiete $I = \times_{i = 1}^n [a_i,b_i]$:

\begin{align*}
\int_{[a_0, b_0]\times I} f(x_0, x_1, \dots, x_n) d(x_0, x_1, \dots, x_n) = 
\int_{a_0}^{b_0} \underbrace{\int_I f(x_0, x_1, \dots, x_n) d(x_1, \dots, x_n)}_{\overline{(f)(x_0)}} dx_0
\end{align*}

So lässt sich die Integration eines mehrdimensionalen Integrals mithilfe einer Funktion \textit{dimDown} schrittweise auf die Auswertung von Integralen niedrigerer Dimension zurückführen.

\begin{align*}
f: \mathbb{R}^{n+1} \rightarrow \mathbb{R}
\end{align*}
\begin{align*}
dimDown(f):& \mathbb{R} \rightarrow \mathbb{R}\\
           & x \mapsto \int_I f(x, x_1, \dots, x_n) d(x_1, \dots, x_n)
\end{align*}

Somit reicht es grundsätzlich skalare Funktionen integrieren zu können.\\

Der Fehler ist bei der Integration von $dimDown(f)$ durch Integration der Fehlerabschätzungen bei den einzelnen Integralen an den Auswertungsstellen berechenbar.

Dies wird in unserer Implementierung im äußersten Integrator miterledigt, wobei gleiche Ordnung,Gewichte und Auswertestellen für Funktion und Fehler verwendet werden.\\

Um bei Verwendung unserer optimierten Funktion $NumInt$ als Integrator auch die Statistiken für die Wahl des besten Verfahrens mitführen und aufaddieren zu können, wird unsere Funktion zu Beginn des Aufrufes um ein zusätzliches Array $A$ erweitert.
Im skalaren Fall wird dieses einfach als $0$-Array mitgeführt.

\subsection{Grundstruktur}

Um im folgenden die erwähnte Erweiterung um das Statistikarray durchzuführen verwenden wir im folgenden die Funktion $mapWithStats$.

\lstinputlisting{mapWithStats.m}

Unsere allgemeinere Funktion $mulDimInt$ arbeitet nun mit einem allgemeinen eindimensionalen Integrator $Integrator$ (wie etwa $NumInt$) und erwartet als Argumente außerdem eine (mehrdimensionale) Funktion $f$, Arrays $a$ und $b$ mit unteren und oberen Integralgrenzen und eine Genauigkeitsvorgabe $epsilon$.

\lstinputlisting{mulDimInt.m}

\subsection{Integratoren}

Ähnlich wir im eindimensionalen Fall haben wir die Verfahren $newton\_cotes$ und $gauss$ implementiert, die auf weitere unveränderten Funktionen aus dem 3.Projekt zurückgreifen.

Es wurden hier Änderungen durchgeführt um die Fehler und Statistiken hochziehen zu können.

\lstinputlisting{newton_cotes.m}

\lstinputlisting{gauss.m}

Die Funktion $NumInt$ ist wiederum unser bevorzugter Integrator, der nun aus Effizienzgründen kein Romberg-Verfahren mehr verwendet.

\lstinputlisting{NumInt.m}

\subsection{Optimierung}

Speziell für den Integrator $NumInt$ haben wir die Effizienz der Berechnung von $mulDimInt$ in der Funktion $mulDimIntOpt$ durch die Vorberechnung der Arrays für Newton-Cotes und Gauss-Integration gesteigert.

\lstinputlisting{mulDimIntOpt.m}

\section{Beispiele}

\newpage

\section{Alternative Implementierung}

Dieser Abschnitt behandelt eine grobe, alternative Implementierung der
numerischen Integration von Funktionen $f: \mathbb R^n \to \mathbb R$
f"ur $n < \omega$ "uber einen Hyperquader $\prod_{i < n} [a_i, b_i]
\subseteq \mathbb R^n$, $a_i, b_i \in \mathbb R$.
. Die Idee ist den Integrationsbereich als Teilmenge des $\mathbb R^n$
bei Bedarf in kleinere Hyperquader zu teilen, anstatt sofort den Satz von Fubini
anzuwenden und bei der Integration der eindimensionalen Funktionen jeweils
bei Bedarf $\mathbb R$ zu teilen, in der Hoffnung so problematische
Bereiche besser isolieren zu k"onnen.

Das inh"arente Problem der Integration im Mehrdimensionalen des
exponentiell mit der Dimension wachsenden Aufwands konnte nat"urlich auch
mit dieser Implementierung nicht beseitigt werden.

Die Integration erfolgt folgender folgenderma"sen:
unterscheidet sich der relative Abstand der Werte der Integration mittels eines
Hyperw"urfelgitters mit $6^n$ und
$8^n$ St"utzstellen, dh. $6$ bzw. $8$ St"utzstellen in jeder Dimension,
wobei entlang jeder Dimension nach Newton-Cotes gewichtet aufsummiert wird
um mehr als $12 - t$ Stellen, wobei $t$ die Anzahl der bisher erfolgten
Teilungen des Integrationsbereichs ist, unterscheidet wird erneut geteilt,
ansonsten der Wert der Integration mit $8^n$ Stellen zur"uckgegeben.
Die Genauigkeitsanforderung nimmt also mit der Anzahl der Teilungen ab,
um eine Termination in vertretbarer Zeit auch bei unangenehmen Funktionen
zu erzwingen.

Die Schranke $12 - t$ wurde experimentell als im Allgemeinen vern"uftig
verifiziert, kann aber nat"urlich f"ur spezielle Klassen von Funktionen
geeignet verbessert werden. Genauso hat sich gezeigt, dass die Rechenzeit
bei Funktionen deren Ordnung den Exaktheitsgrad der Newton-Cotes-Integration
"ubersteigen, verglichen mit solchen die es nicht tun, stark zunimmt.
Ist also zu erwarten, dass vorwiegend Funktionen hoher Ordnungen
integriert werden sollen, ist eine geeignete Erh"ohung der Werte $6$ und
$8$ anzuraten.

Es sei weiters bemerkt, dass die Integration integrierbarer Funktionen
mit Singularit"aten scheitert.

\lstinputlisting{alternative_implementation/integriereQuader.m}

Die folgende Funktion ist lediglich eine Verpackung der Funktion
\lstinline|integriereQuader.m|, sodass diese nicht jedesmal explizit
mit $0$ Teilungen gestartet werden muss.

\lstinputlisting{alternative_implementation/integriereVerpackung.m}

\lstinputlisting{alternative_implementation/werteAusUndSummiere.m}


\end{document}
